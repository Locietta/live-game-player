# 中期总结

生命游戏项目的一轮迭代完成，已经实现了界面显示、随机初始化地图和鼠标点击响应的功能。

## 效果图

<img src="中期检查（感想）.assets/image-20210718085717287.png" alt="image-20210718085717287" style="zoom:67%;" />

点击左上角区域可以实现小方块黑白颜色切换，初始的黑白色块是随机生成的，灰色区域为按钮所预留。

本项目代码可以在Win10和Linux上编译（需要支持C++17的编译器）。

## 协作情况

### 时间线概览

<img src="中期检查（感想）.assets/image-20210718090916468.png" alt="image-20210718090916468" style="zoom:67%;" />

![装配](中期检查（感想）.assets/image-20210718091018096.png)

### 代码托管平台选择

由于Github连接不稳定，我们采用Gitee作为代码托管平台。

### 工作流

每个人开一个分支写各自负责的模块，然后push到远程平台上。最后由项目管理或者编写者在Gitee上发起pull request，审查和测试通过后合并到master分支。

> 不过中间出了一些混乱，model/viewmodel分支提交到了view分支上，还有一些分支是本地合并的，所以时间线不是很清晰。

### 分工

杨林涛：view-model和model分支开发编写

陈德翰：view分支编写

王灵鑫：代码审查和合并、app装配分支编写

## 技术难点克服及总体心得

#### MVVM开发框架的建立

一开始对MVVM框架的理解不太到位，走了一些弯路。

> **一些不好的实现**：
>
>  1. 直接使用回调函数绑定的方式来实现消息传递
>
>     > 扩展不便，每个回调都要增加一个接口。相比之下消息队列更加简单统一
>
>  2. view和view-model之间没有用数据绑定来实现交互，而是采用get_xx_command的形式获取数据
>
>     > 正确的做法应当是把底层的数据指针传出来，放到view层（可能需要经过view-model转换数据），然后view层直接通过这个指针来读取绘制所需的数据
>
> 3. 消息机制采用事件触发而不是属性改变触发
>
>    > 这样一来每有一个事件就需要增加一个判断，但很可能诸多事件只是以不同的方式改写了同样的一些数据。这么做大大增加了代码的冗余，也使维护变得很困难。

通过老师指导和组内讨论，我们几次修改，最终正确地实现了MVVM框架。

#### 跨平台编译和CMakeLists编写

要实现跨平台编译，编写`CMakeLists.txt`时就应当尽量避免使用`SET`来直接指定编译/链接命令行。（否则由于各种编译器的命令行不一样，编写的CMakeLists就失去了通用性）

现代的CMake提供了一系列命令（如`target_link_library`，`target_include_directories`等）来实现平台、编译器无关地指定链接库和include路径。此外，预编译头等也可以用`target_precompile_headers`等命令进行设定。

整体组织上，每个模块（子文件夹）都应当有一个`CMakeLists.txt`，把模块编译为一个库，并且用`target_include_library(xx INTERFACE xxpath)`来指定链接这个模块需要包含的头文件。这样做可以避免在顶层的`CMakeLists.txt`写一长串的include路径，同时也更利于复用模块。

一般CMake会自动根据平台来选择编译器和生成器(`makefile`,`ninja`,`visual studio`等)，不过也可以通过如下命令行来指定

```shell
cmake -DCMAKE_C_COMPILER:FILEPATH=<compiler path> -G <generator>
cmake --build build # 自动用对应的generator进行编译

# 例如下面就是我们在linux上使用的cmake命令行
cmake -S . -B ./build -DCMAKE_C_COMPILER:FILEPATH=/usr/bin/clang-12 -G Ninja
cmake --build build -j6
```

> 一般我们把生成的文件生成到./build文件夹下，这样可以避免和源代码与文件混到一起

### FLTK界面库的使用

#### 安装和链接

我们使用包管理器（用的是`MSYS2`和`ArchLinux`共同的包管理器`pacman`）来安装fltk库，因此头文件和库会直接被放到在编译器的标准路径里。

```
#include <Fl/Fl.H>  // 代码中直接include头文件

target_link_library(xxx fltk) # CMakeLists.txt中指定链接fltk
```

#### 官方文档

遇到问题查阅网页版的[fltk官方文档](https://www.fltk.org/doc-1.3/index.html)可以解决大部分问题。

#### 使用Fl_group和继承

我们的项目需要利用一个二维的`Fl_Box`数组来实现显示功能，本来采用的办法是自己组装了一个类，然后使用主窗口指针（需要主窗口的`begin()`和`end()`不然无法显示）来绘制。 

经过老师的指点，可以使用`Fl_Group`来完成功能，而不必知道主窗口的信息。

### 使用clang工具链

本次项目采用了clang/LLVM的工具链。好处是可以直接使用clang工具链中提供的lint、静态检查和格式化等功能。

clang提供的静态分析工具基于clang编译前端，会首先对代码做简单的parse，得出的结果快速而准确。同时这些工具又有丰富的文档和良好的可扩展性，所以可以有效地根据项目需求进行配置。

主目录下的`.clang-format`作为格式化配置文件，使用clang-format格式化，可以使多人协作项目的代码风格得到统一。

> 不过vscode对windows下的clangd支持不是很好，会有一些比较奇怪的问题（但编译是正常的）

## 个人心得

### 王灵鑫

这次项目作为项目经理和组长，管理整个repo，这让我对整个多人协作开发的流程了解更加深刻，MVVM开发的思想对我很有启发。

现代C++的语法我还是比较熟悉的，不过这些语法在实际的项目中该如何使用，模板元、函数式、面向对象等各种不同的特性之间该如何取舍，这次项目让我学到很多。

这次我做的工作比较零碎，装配app层、代码审查、测试和整个项目文件组织都是我负责。由于对项目整体比较了解，所以还需要协调各个模块之间接口和需求的沟通，有时需要帮忙修改部分代码。

感觉我主要困难的工作都是在写各种配置和研究各种工具，包括`cmake`，`clang`，`.gitignore`，`pacman`等等的配置文件，对整个工程各种配置和各种工具有了更深的理解。

另外由于vscode插件对windows上的clang静态分析工具支持不太好，这次项目我是通过ssh连接到远程linux机器上开发的，也借此熟悉了一下远程开发的模式。

### 杨林涛

C++小学期我感觉这几天学到的关于C++的要比OOP要多一些。比如很多C++11的新功能，像是lambda，伪函数，`std::function`等，这些也在MVVM的消息机制中也有运用，这也是我第一次体验函数式编程。右值引用、移动构造和智能指针也可以在资源绑定中预防野指针和意外地释放内存。我也知道了像FLTK之类用于GUI的库。

我负责的模块是Model和ViewModel模块，Model模块储存记录方块存活状态的矩阵，以及随机生成该矩阵和计算下一步的方块位置。ViewModel模块会连接Model模块，暴露Model的二维矩阵给View，以及转发Notification给View。

我之后会加入一些可用的实例，这些例子以文件的形式存在硬盘里，它们是这个游戏的特解。

### 陈德翰

搭建MVVM框架特别困难。

我觉得收获最大的是，对模块之间消息转发的机制有了更深入的理解。通过发送和接收函数对象的方式，模块之间的通信不需要互相include，可以直接预保留通信接口，这样使同步开发变得很方便。

此外，版本控制工具的使用也让合作变得非常顺畅。